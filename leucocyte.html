<html>
	<head>		 

		<script id="vertex" type="x-shader"> 
		    attribute vec2 vertexPos;
			
		    void main() {
		        gl_Position = vec4(vertexPos, 0.0, 1.0);
			}			
		</script> 
		
		<script id="fragment" type="x-shader">
			#ifdef GL_ES
			precision highp float;
    		#endif
			
			varying vec2 vTextureCoord;
			
			uniform vec3 iResolution;
			uniform float iGlobalTime;
			uniform float vignetteVariation;
			uniform float moduloSpd;
            uniform float globalDensity;
            uniform float sphereSize;
			uniform vec2 iMouse;
			uniform float fogDistFactor;
			uniform vec3 fogCol;
			uniform vec3 vuv;
			uniform float sphereDistort;
			
			 const float maxe=0.001;
			 const int maxiter=256;
			const vec3 modulusSize = vec3(1.2, 1.2, 1.2);
			const float raymarch_max_dist = 50.0;
			

			vec3 modulus(
			  in vec3 p,
			  in vec3 s)
			{
			  return mod(p,s)-0.5*s;
			}

			float snoise( vec2 p ) {
				vec2 f = fract(p);
				p = floor(p);
				float v = p.x+p.y*1000.0;
				vec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);
				r = fract(100000.0*sin(r*.001));
				f = f*f*(3.0-2.0*f);
				return 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;
			}

			float sdSphere( vec3 p, float s )
			{
			  return length(p)-s;
			}			
			//Object
			float obj(in vec3 p, in float f)
			{ 
				// repeat
			  vec3 myMod = vec3(modulusSize.x * (1.0 + 0.2*sin(p.y + moduloSpd)), modulusSize.y * (1.0 + 0.2*cos(p.z + moduloSpd)), modulusSize.z * (1.0 + 0.2 * cos(p.x + moduloSpd)));
                          float density = globalDensity;
                          myMod = myMod / density;
			  vec3 fp=modulus(p, myMod);
			  
			  
			  float sphereDist = sdSphere(fp, sphereSize);
//			  sphereDist -= length(2.0*gl_FragCoord.xy/iResolution.xy-0.5) * sphereDistort * 1.0-(f/raymarch_max_dist);
			  sphereDist += length(2.0*gl_FragCoord.xy/iResolution.xy-0.5) * sphereDistort * 1.0-(f/raymarch_max_dist);
			  return sphereDist;
			}


			float PI=3.14159265;

			float raymarching(
			  in vec3 prp,
			  in vec3 scp,
			  in int maxite,
			  in float precis,
			  in float startf,
			  in float maxd,
			  out int objfound,
			  out float iterCount)
			{ 
			  const vec3 e=vec3(0.1,0,0.0);
			  float s=startf;
			  vec3 c,p,n;
			  float f=startf;
			  objfound=1;
			  iterCount = 0.0;
			  for(int i=0;i<maxiter;i++){
				if (abs(s)<precis||f>maxd||i>maxite) break;
				f+=s;
				p=prp+scp*f;
				s=0.95*obj(p, f);
				iterCount += 1.0;
			  }
			  if (f>maxd) objfound=-1;
			  return f;
			}

			vec3 camera(
			  in vec3 prp,
			  in float vpd)
			{
			  vec2 vPos=-1.0+2.0*gl_FragCoord.xy/iResolution.xy;
			  vec3 vpn=normalize(-prp);
			  vec3 u=normalize(cross(vuv,vpn));
			  vec3 v=cross(vpn,u);
			  vec3 scrCoord=prp+vpn*vpd+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;
			  return normalize(scrCoord-prp);
			}

			vec3 normal(in vec3 p, in float f)
			{
			  //tetrahedron normal
			  const float n_er=0.01;
			  float v1=obj(vec3(p.x+n_er,p.y-n_er,p.z-n_er), f);
			  float v2=obj(vec3(p.x-n_er,p.y-n_er,p.z+n_er), f);
			  float v3=obj(vec3(p.x-n_er,p.y+n_er,p.z-n_er), f);
			  float v4=obj(vec3(p.x+n_er,p.y+n_er,p.z+n_er), f);
			  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));
			}

			vec3 render(
			  in vec3 prp,
			  in vec3 scp,
			  in int maxite,
			  in float precis,
			  in float startf,
			  in float maxd,
			  in vec3 background,
			  out vec3 n,
			  out vec3 p,
			  out float f,
			  out int objfound)
			{ 
			  objfound=-1;
			  float iterCount;
			  f=raymarching(prp,scp,maxite,precis,startf,maxd,objfound, iterCount);
			  if (objfound>0){
					p=prp+scp*f;
					n=normal(p, f);
					float noiseColor = snoise(n.xy * 1000.0);
					float vignetting = 0.0;//length(abs(gl_FragCoord.xy/iResolution.xy-0.5));
					vec3 fogColor = f/raymarch_max_dist * fogDistFactor * fogCol;
					vec3 iterColor = (max(1.0-iterCount*0.01, 0.0) * 0.7 + vec3(n.x, n.y, n.z) * 0.3);
//					return fogCol;
					return  iterColor * 0.5 + fogColor;// - vignetting * vignetteVariation + noiseColor * 0.2;
			  }
			  f=maxd;
			  return vec3(background); //background color
			}

			vec4 main2(void){
			 
			  //Camera animation
			  vec3 prp= vec3(12.0*cos(iGlobalTime * 0.1), 1.0+0.9*sin(iGlobalTime*0.05 - gl_FragCoord.x/iResolution.x), 12.0*sin(iGlobalTime * 0.1));
			  			  
			  vec3 scp=camera(prp,1.5);
			  vec3 n,p;
			  float f;
			  int o;
			  const float startf=0.1;
			  const vec3 backc=vec3(0.8,0.9,1.0);
			  const vec3 ambi=vec3(0.1,0.1,0.1);
			  
			  vec3 c1=render(prp,scp,maxiter,maxe,startf,raymarch_max_dist,backc,n,p,f,o);
				return vec4(c1.xyz,1.0);				
			}			
			
			void main() {
				gl_FragColor = main2();
		    }
		</script> 
		
		
		<script type="text/javascript">
			var time = 0;
			var gl;
			var isMouseDown = false;

                        var density = 1;
                        var sphereSize = .3;
			
			document.onmousemove=getMouseCoordinates;
			document.onmousedown=mouseDown;
			document.onmouseup=mouseUp;

			function init(){
				canvas = document.getElementById("mycanvas");
				gl = canvas.getContext("experimental-webgl");

				gl.viewport(0, 0, canvas.width, canvas.height);	
				gl.clearColor(0.5, 0, 0, 1);
				gl.clear(gl.COLOR_BUFFER_BIT);

				var v = document.getElementById("vertex").firstChild.nodeValue;
				var f = document.getElementById("fragment").firstChild.nodeValue;
				
				var vs = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(vs, v);
				gl.compileShader(vs);
				
				var fs = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(fs, f);
				gl.compileShader(fs);

				program = gl.createProgram();
				gl.attachShader(program, vs);
				gl.attachShader(program, fs);
				gl.linkProgram(program);
				
				if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) 
					console.log(gl.getShaderInfoLog(vs));
					
				if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) 
					console.log(gl.getShaderInfoLog(fs));
				
				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) 
					console.log(gl.getProgramInfoLog(program));
					
				var aspect = canvas.width / canvas.height;
				
				var vertices = new Float32Array([
					-1, -1, 1, -1,  1, 1,
					-1, -1, 1, 1, -1,1
					]);
				
				vbuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);					
				gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
				
				itemSize = 2;
				numItems = vertices.length / itemSize;

				gl.useProgram(program); 

				program.iResolution = gl.getUniformLocation(program, "iResolution");
				gl.uniform3fv(program.iResolution, [canvas.width, canvas.height, 1.0]);

				program.vertexPos = gl.getAttribLocation(program, "vertexPos");
				gl.enableVertexAttribArray(program.vertexPos);
				gl.vertexAttribPointer(program.vertexPos, itemSize, gl.FLOAT, false, 0, 0);

				program.iGlobalTime = gl.getUniformLocation(program, "iGlobalTime");
				program.vignetteVariation = gl.getUniformLocation(program, "vignetteVariation");
				program.globalDensity = gl.getUniformLocation(program, "globalDensity");
				program.sphereSize = gl.getUniformLocation(program, "sphereSize");
				program.moduloSpd = gl.getUniformLocation(program, "moduloSpd");
				program.iMouse = gl.getUniformLocation(program, "iMouse");
				program.fogDistFactor = gl.getUniformLocation(program, "fogDistFactor");
				program.fogCol= gl.getUniformLocation(program, "fogCol");
				program.vuv= gl.getUniformLocation(program, "vuv");
				program.sphereDistort = gl.getUniformLocation(program, "sphereDistort");
			
				
				window.requestAnimFrame = (function(){
				  return  window.requestAnimationFrame       ||
						  window.webkitRequestAnimationFrame ||
						  window.mozRequestAnimationFrame    ||
						  function( callback ){
							window.setTimeout(callback, 1000 / 30);
						  };
				})();
				
				(function animloop(){
				  requestAnimFrame(animloop);
                                  var newtime = document.getElementById("music").currentTime;
                                  if (newtime != time) {
                                      time = newtime;
                                      //console.log("Time: " + time);
                                      render();
                                  }
				})();				

		}
		
			var mouseCoordsX = 0;
			var mouseCoordsY = 0;
			var virtMouseCoords = [0,0];
			
			function getMouseCoordinates(event)
			{
				var vx = window.event.pageX;
				var vy = window.event.pageY;
				if (isMouseDown) {
					var dx = vx - mouseCoordsX;
					var dy = vy - mouseCoordsY;
					virtMouseCoords[0] += dx;
					virtMouseCoords[1] += dy;
				}
				mouseCoordsX = vx;
				mouseCoordsY = vy;
			}			

			function mouseDown(event) {
				isMouseDown = true;
			}			

			function mouseUp(event) {
				isMouseDown = false;
			}			

                        function sin(x) { return Math.sin(x); }
			
                        var end = 184.7;
                        function scenario(time) {
                            var initialDensity = .1;
                            var diam = .25;
                            var program = [
                            { at: 0, do: function(t, l) {
                                           density = (t/l) * initialDensity;
                                           sphereSize = Math.min(2.0, 0.3 / density);
                                         } },
                            { at: 6, do: function(t, l) {
                                           density = (t / l) * (1 - initialDensity) + initialDensity;
                                           sphereSize = Math.min(2.0, 0.3 / density);
                                         } },
                            { at: 21, do: function(t, l) {
                                           density = 1 + sin(t / 4.56) / 4;
                                           sphereSize = Math.min(2.0, 0.3 / density);
                                         } },
                            { at: 121, do: function(t, l) {
                                           density = 1 + sin(t / 4.56) / 4;
                                           sphereSize = diam + sin(time * Math.PI * 4) / 8;
                                         } },
                            { at: 140, do: function(t, l) {
                                           density = 1 + sin(t / 4.56) / 4;
                                           sphereSize = diam + ((l - t) / l) *sin(time * Math.PI * 4) / 8;
                                         } },
                            { at: 145, do: function(t, l) {
                                           density = 1 + sin(t / 4.56) / 4;
                                           sphereSize = .2;
                                         } },
                            { at: 170, do: function(t) {
                                           density = (end - time) / (end - time + t);
                                           sphereSize = Math.min(2.0, 0.3 / density);
                                         } },
                            ];

                            runProgram(program);
                        }

                        function runProgram(program) {
                            for (var i = 0; i < program.length; ++i) {
                                var at = program[i].at;
                                var atNext = (i < (program.length - 1) ? program[i + 1].at : end);

                                if (time > at && time < atNext) {
                                    program[i].do(time - at, atNext - at);
                                }
                            }
                        }

			const BPM = 125.0*2.0;
			const BEAT_OFFSET = 0.0;
			const BAR_DURATION = 60 / BPM;
			const BEAT_EVERY = 4;
			var lastBeatTime = 0.0;
			var nextchange=0.0;
			var beatcount = 0;
			
			
			function  render() {
                scenario(time);
				const DISTORT_AMPLITUDE = 0.5;
				const VIGNETTE_AMPLITUDE = 1.0;
				const VIGNETTE_SCALE = VIGNETTE_AMPLITUDE/DISTORT_AMPLITUDE;

				var distort = DISTORT_AMPLITUDE * Math.sin(time * 0.1);
				var vignette = (DISTORT_AMPLITUDE-Math.abs(distort)) * VIGNETTE_SCALE;

				gl.uniform1f(program.iGlobalTime, time);
				gl.uniform1f(program.sphereDistort, distort);
				gl.uniform1f(program.vignetteVariation, vignette);
				gl.uniform1f(program.globalDensity, density);
				gl.uniform1f(program.moduloSpd, time * 0.25);
				gl.uniform1f(program.fogDistFactor, 1.0 + Math.abs(Math.sin(time * 0.5) * 0.3));
                gl.uniform1f(program.sphereSize, sphereSize);

				
				// update camera up vector
				var angle = time * 0.05;				
				gl.uniform3fv(program.vuv, [-Math.sin(angle), Math.cos(angle), 0.0]);
				
				gl.uniform2fv(program.iMouse, virtMouseCoords);
				
				// CHANGE FOG WITH  BEAT
				if (time >= nextchange) {
					var delta = time-lastBeatTime;
					if (delta >= BAR_DURATION) {					
						lastBeatTime = time + delta;
						beatcount++;
						if (beatcount == BEAT_EVERY) {
							beatcount = 0;
							gl.uniform3fv(program.fogCol, [1.0, 0.8, 0.4]);
							console.log("BEAT");
							nextchange = time + 0.15;
							}
						}
					else
						gl.uniform3fv(program.fogCol, [0.4, 0.8, 1.0]);
				}

				gl.drawArrays(gl.TRIANGLES, 0, numItems);				
			}
			</script>
	</head>
	<body onload="init()">
                <audio id="music" autoplay controls>
                <source src="leucocyte.mp3" type="audio/mpeg">
                </audio>
                <br/>
		<canvas id="mycanvas" width="800" height="600">

	</body>
</html>
